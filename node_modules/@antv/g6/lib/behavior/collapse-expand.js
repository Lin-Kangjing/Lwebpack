var Util = require('../util');

var DEFAULT_ANIMATE = {
  duration: 500,
  delay: 0,
  callback: function callback() {},
  easing: 'easeLinear'
};
module.exports = {
  getDefaultCfg: function getDefaultCfg() {
    return {
      /**
       * 发生收缩/扩展变化时，是否需要重新layout。
       */
      onChange: function onChange() {},
      animate: {}
    };
  },
  getEvents: function getEvents() {
    return {
      'node:click': 'onNodeClick'
    };
  },
  onNodeClick: function onNodeClick(e) {
    var item = e.item;
    var children = item.get('model').data.children; // 叶子节点的收缩和展开没有意义

    if (!children || children.length === 0) {
      return;
    }

    var collapsed = !item.hasState('collapsed');

    if (!this.shouldBegin(e, collapsed)) {
      return;
    }

    item.set('collapsed', collapsed);
    this.graph.emit('itemcollapsed', {
      item: e.item,
      collapsed: collapsed
    });

    if (!this.shouldUpdate(e, collapsed)) {
      return;
    }

    var autoPaint = this.graph.get('autoPaint');
    this.graph.setAutoPaint(false);
    this.updateLayout(item, collapsed);
    this.setChildrenState(item, 'collapsed', collapsed);
    this.graph.setAutoPaint(autoPaint);
  },
  updateLayout: function updateLayout(item, isCollapsed) {
    var graph = this.graph;
    var data = this.onChange(item, isCollapsed);

    if (data) {
      data = typeof data === 'boolean' ? graph.get('data') : data;

      if (graph.get('layout')) {
        data = graph.get('layout')(data);
      }

      if (this.animate) {
        // 有动画，且有重布局，先停掉原有动画
        if (this.graph.isLayoutAnimating()) {
          this.graph.stopLayoutAnimate();
        } // 计算每个节点移动的起始位置和最终位置


        this.animateChild(data);
        this.performAnimate();
      } else {
        var autoPaint = graph.get('autoPaint');
        graph.setAutoPaint(false);
        Util.traverseTree(data, function (child) {
          var node = graph.findById(child.id);
          node.get('model').x = child.x;
          node.get('model').y = child.y;
        });
        graph.refresh();
        Util.traverseTree(item.get('model').data, function (child) {
          var node = graph.findById(child.id);

          if (node === item) {
            return;
          }

          if (isCollapsed) {
            graph.hideItem(node);
          } else {
            graph.showItem(node);
          }
        });
        graph.paint();
        graph.setAutoPaint(autoPaint);
      }
    } else {
      if (this.animate) {
        // 没有重布局，有动画的情况
        var model = item.get('model');

        if (isCollapsed) {
          this.collapsePosition(item, {
            x: model.x,
            y: model.y
          });
        } else {
          this.expandPosition(item, {
            x: model.x,
            y: model.y
          });
        }

        this.performAnimate();
      } else {
        // 没有重布局，没有动画
        if (isCollapsed) {
          this.collapse(item);
        } else {
          this.expand(item);
        }

        this.graph.paint();
      }
    }
  },
  // 执行位置动画
  performAnimate: function performAnimate() {
    var self = this;
    var animate = Util.mix({}, DEFAULT_ANIMATE, self.animate);
    var graph = self.graph;
    graph.layoutAnimate(graph.get('data'), function (node, ratio, origin) {
      var to = node.get('toPosition');

      if (to) {
        return {
          x: origin.x + (to.x - origin.x) * ratio,
          y: origin.y + (to.y - origin.y) * ratio
        };
      }
    }, animate.duration, animate.easing, function () {
      Util.each(graph.get('nodes'), function (node) {
        if (node.get('shouldHide')) {
          node.set('shouldHide', false);
          graph.hideItem(node);
        }

        node.set('toPosition', null);
      });
      graph.paint();
      animate.callback();
    }, animate.delay);
  },
  // 根据最新layout，整理节点位置
  animateChild: function animateChild(data) {
    var self = this;
    var node = self.graph.findById(data.id);
    var nodeModel = node.get('model');
    var point = {
      x: data.x,
      y: data.y
    };

    if (Util.isNil(point.x) || Util.isNil(point.y)) {
      var model = node.get('parent').get('model');
      point.x = model.x;
      point.y = model.y;
    }

    if (nodeModel.x !== point.x || nodeModel.y !== point.y) {
      node.set('toPosition', {
        x: point.x,
        y: point.y
      });
    } // 还是展开状态的子节点，也做位移动画


    Util.each(data.children, function (child) {
      self.animateChild(child, data);
    }); // 收缩状态的节点，都跑收缩动画

    if (node.get('collapsed')) {
      self.collapsePosition(node, point);
    }

    self.graph.showItem(node);
  },
  // 收缩的节点的动画终态是最顶收缩态节点的坐标
  collapsePosition: function collapsePosition(node, toPoint) {
    var self = this;
    Util.each(node.get('model').children, function (child) {
      child = self.graph.findById(child.id);
      var model = child.get('model');

      if (!child.get('originPosition')) {
        child.set('originPosition', {
          x: model.x,
          y: model.y
        });
      }

      child.set('toPosition', {
        x: toPoint.x,
        y: toPoint.y
      });
      child.set('shouldHide', true);

      if (!child.get('collapsed')) {
        self.collapsePosition(child, toPoint);
      }
    });
  },
  // 张开的节点，从startPoint开始，动画到节点原本的位置
  expandPosition: function expandPosition(item, startPoint) {
    var self = this;
    var children = item.get('model').children;
    Util.each(children, function (child) {
      child = self.graph.findById(child.id);
      self.graph.showItem(child);
      var origin = child.get('originPosition');
      child.set('toPosition', {
        x: origin.x,
        y: origin.y
      });

      if (!child.get('collapsed')) {
        self.expandPosition(child, startPoint);
      }
    });
  },
  // 设置子节点的状态
  setChildrenState: function setChildrenState(item, state, enabled) {
    var self = this; // 如果父节点展开了，子节点还有原本就收缩的，不设置这个子树的状态

    if (!enabled && item.get('collapsed')) {
      return;
    }

    self.graph.setItemState(item, state, enabled);
    Util.each(item.get('model').children, function (child) {
      var node = self.graph.findById(child.id);
      self.setChildrenState(node, state, enabled);
    });
  },
  // 不包含动画，仅展示展开节点
  expand: function expand(item) {
    var self = this;
    var graph = self.graph;

    if (item.get('collapsed')) {
      graph.showItem(item);
      return;
    }

    graph.showItem(item);
    Util.each(item.get('model').children, function (child) {
      var node = self.graph.findById(child.id);
      self.expand(node);
    });
  },
  // 不包含动画，仅隐藏收缩节点
  collapse: function collapse(item) {
    var self = this;
    var graph = self.graph;
    graph.setItemState(item, 'collapsed', true);
    Util.each(item.get('model').children, function (child) {
      var node = graph.findById(child.id);
      self.collapse(node);
      self.graph.hideItem(node);
    });
  }
};